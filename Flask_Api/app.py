import decimal
from flask import Flask, request, jsonify
import mysql.connector
import joblib
import numpy as np
import pandas as pd
from flask_cors import CORS
from datetime import datetime


app = Flask(__name__)
CORS(app)

# ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• DecisionTree ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
model = joblib.load('Flask_Api/food_recommendation_model.pkl')

# ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• RandomForest ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)
rf_model = joblib.load('Flask_Api/random_forest_model.pkl')

# ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ preprocessing tools ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏Ñ‡∏π‡πà‡∏Å‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏• RandomForest
scaler = joblib.load('Flask_Api/scaler.pkl')  # ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏™‡πÄ‡∏Å‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
imputer = joblib.load('Flask_Api/imputer.pkl')  # ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ (missing values)
label_encoder = joblib.load('Flask_Api/label_encoder.pkl')  # ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
category_encoder = joblib.load('Flask_Api/category_encoder.pkl') # ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

# ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå (features) ‡∏ó‡∏µ‡πà‡πÇ‡∏°‡πÄ‡∏î‡∏• RandomForest ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
RF_MODEL_FEATURES = ['calories', 'protein', 'carbohydrate', 'sugar', 'fat', 'sodium',
                     'category_encoded', 'sugar_to_carb_ratio', 'fat_to_calorie_ratio']



# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• MySQL
def get_db_connection():
    try:
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="",
            database="food_recommend_system"
        )
        return conn
    except mysql.connector.Error as err:
        print(f"Error connecting to MySQL: {err}")
        raise

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢ ID ‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest)
def predict_food_type_by_id(food_id: int): # ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ food_id ‡πÉ‡∏´‡πâ‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö schema
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    try:
        # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ food_id)
        cursor.execute("SELECT * FROM food_menu WHERE food_id = %s", (food_id,))
        row = cursor.fetchone()

        if not row:
            return {'error': 'Food item not found'}

        df = pd.DataFrame([row])

        # ‡πÅ‡∏õ‡∏•‡∏á category ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏•‡∏Ç‡∏ï‡∏≤‡∏° encoder ‡∏ó‡∏µ‡πà‡πÄ‡∏ó‡∏£‡∏ô‡πÑ‡∏ß‡πâ
        df['category_encoded'] = category_encoder.transform(df[['category']])

        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≠‡∏Ñ‡∏≤‡∏£‡πå‡πÇ‡∏ö‡πÑ‡∏Æ‡πÄ‡∏î‡∏£‡∏ï (‡πÄ‡∏û‡∏¥‡πà‡∏° 1e-8 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏®‡∏π‡∏ô‡∏¢‡πå)
        df['sugar_to_carb_ratio'] = df['sugar'] / (df['carbohydrate'] + 1e-8)
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≠‡πÅ‡∏Ñ‡∏•‡∏≠‡∏£‡∏µ‡πà (‡πÄ‡∏û‡∏¥‡πà‡∏° 1e-8 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏®‡∏π‡∏ô‡∏¢‡πå)
        df['fat_to_calorie_ratio'] = df['fat'] / (df['calories'] + 1e-8)

        # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        X = df[RF_MODEL_FEATURES] # ‡πÉ‡∏ä‡πâ Global RF_MODEL_FEATURES

        # ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ (imputation) ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏™‡πÄ‡∏Å‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (scaling)
        X_imputed = imputer.transform(X)
        X_scaled = scaler.transform(X_imputed)

        # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest
        y_pred = rf_model.predict(X_scaled)
        # ‡πÅ‡∏õ‡∏•‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç) ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°)
        predicted_label = label_encoder.inverse_transform(y_pred.ravel()) # Added .ravel()

        return {
            'food_id': food_id,
            'food_name': row['food_name'], 
            'predicted_food_type': predicted_label[0]
        }

    except Exception as e:
        return {'error': str(e)}

    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö DataFrame ‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest)
def predict_food_types_for_dataframe(df: pd.DataFrame):
    """
    ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô DataFrame
    ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest ‡∏ó‡∏µ‡πà‡∏ù‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
    DataFrame (df) ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö RF_MODEL_FEATURES

    ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤:
        - numpy.ndarray ‡∏Ç‡∏≠‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ
        - pandas.Index ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
    ‡∏´‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ ‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ (numpy.array([]), pandas.Index([]))
    """
    if df.empty:
        return np.array([]), pd.Index([])


    df_processed = df.copy()

    # ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest
    numeric_cols_for_rf = ['calories', 'protein', 'carbohydrate', 'sugar', 'fat', 'sodium']
    for col in numeric_cols_for_rf:
        # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç, ‡∏ñ‡πâ‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏à‡∏∞‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô NaN (Not a Number)
        df_processed[col] = pd.to_numeric(df_processed[col], errors='coerce')
    
     # ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏• RF ‡πÄ‡∏õ‡πá‡∏ô NaN (‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)
    df_processed.dropna(subset=numeric_cols_for_rf, inplace=True)
    if df_processed.empty:
        print("‚ÑπÔ∏è DataFrame ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏•‡∏∞‡∏•‡∏ö NaN ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå RF")
        return np.array([]), pd.Index([])

    # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 'category' (‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏≠‡∏≤‡∏´‡∏≤‡∏£)
    if 'category' not in df_processed.columns:
        print("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 'category' ‡πÉ‡∏ô DataFrame, ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤")
        return np.array([]), pd.Index([])
    
    # ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ NaN ‡∏´‡∏£‡∏∑‡∏≠ None ‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 'category' ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ encode
    # ‡πÇ‡∏î‡∏¢‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏ß‡∏¢ 'Unknown' ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤ default ‡∏≠‡∏∑‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
    df_processed['category'] = df_processed['category'].fillna('Unknown') # Or a more appropriate default
    
    try:
        # ‡πÅ‡∏õ‡∏•‡∏á 'category' ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏î‡πâ‡∏ß‡∏¢ category_encoder
        df_processed['category_encoded'] = category_encoder.transform(df_processed[['category']])
    except Exception as e:
        # ‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î error ‡∏ñ‡πâ‡∏≤ category_encoder ‡πÄ‡∏à‡∏≠‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏≠‡∏ô‡∏ù‡∏∂‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•
        # ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö unknown values
        print(f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£ encode ‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö batch prediction: {e}. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å")
        return np.array([]), pd.Index([])


    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà
    df_processed['sugar_to_carb_ratio'] = df_processed['sugar'] / (df_processed['carbohydrate'] + 1e-8)
    df_processed['fat_to_calorie_ratio'] = df_processed['fat'] / (df_processed['calories'] + 1e-8)

    # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå, ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ (impute), ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏™‡πÄ‡∏Å‡∏• (scale)
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡πÇ‡∏°‡πÄ‡∏î‡∏• RF ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    missing_features = [f for f in RF_MODEL_FEATURES if f not in df_processed.columns]
    if missing_features:
        print(f"‚ö†Ô∏è ‡∏Ç‡∏≤‡∏î‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏• RF: {missing_features}. ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤")
        return np.array([]), pd.Index([])
    X = df_processed[RF_MODEL_FEATURES]
    
    try:
        X_imputed = imputer.transform(X) # ‡πÉ‡∏ä‡πâ imputer ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ß‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
        X_scaled = scaler.transform(X_imputed) # ‡πÉ‡∏ä‡πâ scaler ‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ß‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏™‡πÄ‡∏Å‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    except Exception as e:
        print(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£ imputation/scaling: {e}")
        return np.array([]), pd.Index([])

    if X_scaled.shape[0] == 0:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        print("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô preprocessing")
        return np.array([]), pd.Index([])

    # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏•‡∏î‡πâ‡∏ß‡∏¢‡πÇ‡∏°‡πÄ‡∏î‡∏• Random Forest
    y_pred_numeric = rf_model.predict(X_scaled)
    # ‡πÅ‡∏õ‡∏•‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç) ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°)
    predicted_type_names = label_encoder.inverse_transform(y_pred_numeric.ravel()) # Added .ravel()
    # ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ ‡πÅ‡∏•‡∏∞ index ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
    # ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ô‡∏≥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÑ‡∏õ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    return predicted_type_names, df_processed.index 

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡∏Å‡∏ï‡πå‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö JSON
def convert_to_json_safe(obj):
    if isinstance(obj, list):
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏¥‡∏™‡∏ï‡πå ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡πÉ‡∏ô‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô JSON-safe
        return [convert_to_json_safe(item) for item in obj]
    elif isinstance(obj, dict):
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏î‡∏¥‡∏Å‡∏ä‡∏±‡∏ô‡∏ô‡∏≤‡∏£‡∏µ ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏µ‡∏¢‡πå‡πÅ‡∏•‡∏∞‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô JSON-safe
        return {key: convert_to_json_safe(value) for key, value in obj.items()}
    elif hasattr(obj, 'item'):
        # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô NumPy scalar ‡∏´‡∏£‡∏∑‡∏≠ PyTorch tensor ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Python scalar
        return obj.item()
    else:
        # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô, ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
        return obj


# Mapping ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£
food_type_mapping = {
    0: "‡∏™‡∏°‡∏î‡∏∏‡∏•",
    1: "‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥",
    2: "‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥",
    3: "‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥",
    4: "‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥+‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥",
    5: "‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥+‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥",
    6: "‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥+‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥",
    7: "‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥+‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥+‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥"
}
# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£
def get_related_food_types(predicted_food_type_code_from_user_model):
    type_mapping = {
        0: [0],      # ‡∏™‡∏°‡∏î‡∏∏‡∏•
        1: [1],      # ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥
        2: [2],      # ‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥ 
        3: [3],      # ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥
        4: [1, 2],   # ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥ + ‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥
        5: [1, 3],   # ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥ + ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥
        6: [2, 3],   # ‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥ + ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥
        7: [1, 2, 3] # ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏ï‡πà‡∏≥ + ‡πÇ‡∏ã‡πÄ‡∏î‡∏µ‡∏¢‡∏°‡∏ï‡πà‡∏≥ + ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥
    }
    return type_mapping.get(predicted_food_type_code_from_user_model, [0])

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
def get_user_data(username):
    try:
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="",
            database="food_recommend_system"
        )
        cursor = conn.cursor(dictionary=True) 

        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_id_data = cursor.fetchone()

        if user_id_data:
            user_id = user_id_data['users_id'] # Access by column name
            cursor.execute(""" 
                SELECT p.age, p.weight, p.height, p.activity_level, p.bmi, p.diseases, p.gender, p.status_bmi, p.daily_calorie
                FROM users u 
                JOIN profiles p ON u.users_id = p.users_id 
                WHERE u.users_id = %s
            """, (user_id,))
            user_profile_data = cursor.fetchone()

            if user_profile_data:
                # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                age, weight, height, activity_level, bmi, diseases, gender, status_bmi, daily_calorie = \
                    user_profile_data['age'], user_profile_data['weight'], user_profile_data['height'], user_profile_data['activity_level'], user_profile_data['bmi'], user_profile_data['diseases'], user_profile_data['gender'], user_profile_data['status_bmi'], user_profile_data['daily_calorie']


                # ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÇ‡∏£‡∏Ñ
                diseases = diseases.replace(" ", "").strip()

                disease_mapping = {
                    '‡πÑ‡∏°‡πà‡∏°‡∏µ': 0,
                    '‡πÇ‡∏£‡∏Ñ‡πÄ‡∏ö‡∏≤‡∏´‡∏ß‡∏≤‡∏ô': 1,
                    '‡πÇ‡∏£‡∏Ñ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡∏™‡∏π‡∏á': 2,
                    '‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à': 3,
                    '‡πÇ‡∏£‡∏Ñ‡πÄ‡∏ö‡∏≤‡∏´‡∏ß‡∏≤‡∏ô,‡πÇ‡∏£‡∏Ñ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡∏™‡∏π‡∏á': 4,
                    '‡πÇ‡∏£‡∏Ñ‡πÄ‡∏ö‡∏≤‡∏´‡∏ß‡∏≤‡∏ô,‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à': 5,
                    '‡πÇ‡∏£‡∏Ñ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡∏™‡∏π‡∏á,‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à': 6,
                    '‡πÇ‡∏£‡∏Ñ‡πÄ‡∏ö‡∏≤‡∏´‡∏ß‡∏≤‡∏ô,‡πÇ‡∏£‡∏Ñ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡∏™‡∏π‡∏á,‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à': 7
                }
                disease_type = disease_mapping.get(diseases, 0)  # ‡πÄ‡∏£‡∏¥‡πà‡∏° 0

                # Mapping ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                mappings = {
                    "gender": {'‡∏ä‡∏≤‡∏¢': 1, '‡∏´‡∏ç‡∏¥‡∏á': 2},
                    "activity_level": {'‡∏ô‡πâ‡∏≠‡∏¢': 1, '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á': 2, '‡∏°‡∏≤‡∏Å': 3},
                    "status_bmi": {'‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏ì‡∏ë‡πå': 1, '‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏™‡∏°‡∏™‡πà‡∏ß‡∏ô': 2, '‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå': 3, '‡∏≠‡πâ‡∏ß‡∏ô': 4}
                }

                # ‡∏™‡∏£‡πâ‡∏≤‡∏á dictionary ‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•
                user_data_dict = {
                    "age": age,
                    "weight": float(weight),
                    "height": float(height),
                    "activity_level": mappings["activity_level"].get(activity_level, 0),
                    "bmi": float(bmi),
                    "status_bmi": mappings["status_bmi"].get(status_bmi, 0),
                    "diseases": disease_type,  
                    "gender": mappings["gender"].get(gender, 0),
                    "daily_calorie": int(daily_calorie)
                }

                print("‚úÖ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢:", user_data_dict)
                return user_data_dict

        print("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ")
        return None

    except mysql.connector.Error as err:
        print(f"‚ùå MySQL Error: {err}")
        return None

    finally: # ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            if 'cursor' in locals() and cursor: cursor.close()
            if 'conn' in locals() and conn and conn.is_connected(): conn.close()

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (for user - Decision Tree model)
def predict_food_type(user_data_dict): 
    try:
        # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡∏ù‡∏∂‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•
        feature_names = ['Ages', 'Gender', 'Height', 'Weight', 'Bmi', 'Disease_Type', 'Activity_Level']
        input_data = [[
            user_data_dict['age'], user_data_dict['gender'], user_data_dict['height'], user_data_dict['weight'],
            user_data_dict['bmi'], user_data_dict['diseases'], user_data_dict['activity_level']
        ]]
        input_df = pd.DataFrame(input_data, columns=feature_names) # user_data should be user_data_dict

        predicted_food_type_code = model.predict(input_df)[0]
        print(f"‚úÖ ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÇ‡∏°‡πÄ‡∏î„É´‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ (code): {predicted_food_type_code}")

        # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
        food_type_name = food_type_mapping.get(predicted_food_type_code, "‡∏™‡∏°‡∏î‡∏∏‡∏•")
        return predicted_food_type_code, food_type_name

    except Exception as e:
        print(f"‚ùå Error in predict_food_type: {e}")
        return 0, "‡∏™‡∏°‡∏î‡∏∏‡∏•"

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£ ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏à‡∏≤‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏• RF
def get_meal_set(user_predicted_food_type_name: str, target_calories: float):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    meal_set = {}
    meal_categories_to_find = ["‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏à‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏Å", "‡∏ú‡∏•‡πÑ‡∏°‡πâ", "‡∏Ç‡∏ô‡∏°", "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏∑‡πà‡∏°", "‡∏ü‡∏≤‡∏™‡∏ï‡πå‡∏ü‡∏π‡πâ‡∏î"]
    remaining_calories = target_calories

    try:
        # ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• food_menu
        cursor.execute("""
            SELECT food_id, food_name, calories, protein, carbohydrate, sugar, fat, sodium, category, image_url, amount
            FROM food_menu
        """)
        all_foods_raw = cursor.fetchall()

        if not all_foods_raw:
            print("‚ùå No food items found in the database for get_meal_set.")
            return None

        all_foods_df = pd.DataFrame(all_foods_raw)
        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå index ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö index ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
        all_foods_df['original_idx'] = all_foods_df.index


        # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô DataFrame
        rf_predictions_list, processed_indices = predict_food_types_for_dataframe(all_foods_df)
        processed_indices = pd.Index(processed_indices)  # ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Index ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö .loc ‡πÅ‡∏•‡∏∞ .empty ‡πÑ‡∏î‡πâ

        
         # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if rf_predictions_list.size == 0: 
            print(f"‚ÑπÔ∏è RF Model did not return predictions for any food items (or an error occurred during prediction).")
            # ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
            all_foods_df['rf_predicted_food_type'] = pd.Series(dtype='object')
        else:
            # ‡πÅ‡∏õ‡∏•‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô Series ‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÉ‡∏´‡∏°‡πà
            temp_prediction_col = pd.Series(index=all_foods_df.index, dtype='object')
            if not processed_indices.empty: # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                 temp_prediction_col.loc[processed_indices] = rf_predictions_list
            all_foods_df['rf_predicted_food_type'] = temp_prediction_col


        # ‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÅ‡∏•‡πâ‡∏ß
        matched_foods_df = all_foods_df[all_foods_df['rf_predicted_food_type'].isin(user_predicted_food_type_name)]


        if matched_foods_df.empty:
            print(f"‚ùå No food items found where RF model prediction ('{user_predicted_food_type_name}') matches for user.")
            return None

        # ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        for meal_category in meal_categories_to_find:
            # ‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
            matched_foods_df['calories'] = pd.to_numeric(matched_foods_df['calories'], errors='coerce')
            
            candidate_meals_for_category = matched_foods_df[
                (matched_foods_df['category'] == meal_category) &
                (matched_foods_df['calories'] <= remaining_calories) &
                (matched_foods_df['calories'].notna()) # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ calories ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô NaN
            ]

            if not candidate_meals_for_category.empty:
                selected_meal_series = candidate_meals_for_category.sample(1).iloc[0]
                meal_details = {
                    'food_id': selected_meal_series['food_id'],
                    'food_name': selected_meal_series['food_name'],
                    'calories': float(selected_meal_series['calories']),
                    'protein': float(selected_meal_series.get('protein', 0)), # ‡πÉ‡∏ä‡πâ get() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô KeyError
                    'carbohydrate': float(selected_meal_series.get('carbohydrate', 0)),
                    'sugar': float(selected_meal_series.get('sugar',0)),
                    'fat': float(selected_meal_series.get('fat',0)),
                    'sodium': float(selected_meal_series.get('sodium',0)),
                    'category': selected_meal_series['category'],
                    'image_url': selected_meal_series.get('image_url', 'default-image.jpg'),
                    'amount': selected_meal_series.get('amount', '1 ‡∏à‡∏≤‡∏ô')
                }
                meal_set[meal_category] = meal_details
                remaining_calories -= meal_details['calories']
                print(f"‚úÖ Found meal for {meal_category}: {meal_details['food_name']} ({meal_details['calories']} kcal)")
            else:
                print(f"‚ùå No meal found for category: {meal_category} (user type: {user_predicted_food_type_name}, remaining cal: {remaining_calories:.2f})")
        
        if not meal_set:
            print(f"‚ùå No meals could be assembled for user type '{user_predicted_food_type_name}' with target calories {target_calories}.")
            return None
        
        print(f"‚úÖ ‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (user type: {user_predicted_food_type_name}):", meal_set)
        return meal_set

    except mysql.connector.Error as err:
        print(f"‚ùå MySQL Error in get_meal_set: {err}")
        return None
    except Exception as e:
        import traceback
        print(f"‚ùå Unexpected error in get_meal_set: {e}")
        traceback.print_exc()
        return None
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()


# API ‡πÄ‡πÄ‡∏ô‡∏∞‡∏ô‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£
@app.route('/get_recommendations', methods=['POST'])
def get_recommendations():
    try:
        data = request.get_json()
        username = data.get('username')
    
        print(f"üîç ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {username}")  
        
        user_data_dict = get_user_data(username)
        if user_data_dict is None:
            print("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ")
            return jsonify({"error": "User data not found"}), 404

        daily_calorie = user_data_dict['daily_calorie']
        breakfast_calories = daily_calorie * 0.3
        lunch_calories = daily_calorie * 0.4
        dinner_calories = daily_calorie * 0.3

        food_type_code_user, food_type_name_user = predict_food_type(user_data_dict)
        print(f"üíÅ User's predicted food type (for meal selection): {food_type_name_user} (code: {food_type_code_user})")

        # ‡πÅ‡∏õ‡∏•‡∏á code ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏¢‡πà‡∏≠‡∏¢
        related_codes = get_related_food_types(food_type_code_user)
        related_types = [food_type_mapping[code] for code in related_codes]

        print(f"‚úÖ ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á (codes): {related_codes}")
        print(f"‚úÖ ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: {related_types}")

        # ‡∏™‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏õ‡πÉ‡∏´‡πâ get_meal_set ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô
        breakfast = get_meal_set(related_types, breakfast_calories)
        lunch = get_meal_set(related_types, lunch_calories)
        dinner = get_meal_set(related_types, dinner_calories)

        error_meals = []
        if not breakfast: error_meals.append("breakfast")
        if not lunch: error_meals.append("lunch")
        if not dinner: error_meals.append("dinner")

        if error_meals:
            print(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö: {', '.join(error_meals)}")
            return jsonify({"error": f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏î‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏°‡∏∑‡πâ‡∏≠ (‡∏Ç‡∏≤‡∏î: {', '.join(error_meals)})"}), 500
        
        # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô JSON-safe
        response_data = convert_to_json_safe({
            "daily_calorie": daily_calorie,
            "food_type": food_type_name_user,
            "food_type_code": food_type_code_user,
            "meals": {
                "breakfast": breakfast,
                "lunch": lunch,
                "dinner": dinner
            }
        })

        # ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ
        print("‚úÖ JSON Response:", response_data)
        response = jsonify(response_data)
        response.headers['Content-Type'] = 'application/json; charset=utf-8'
        return response, 200

    except Exception as e:
        import traceback
        print(f"‚ùå Error in get_recommendations: {e}")
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

    

# API ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥/‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
@app.route('/get_food_list', methods=['POST'])
def get_food_list():
    try:
        data = request.get_json()
        username = data.get('username')
        if not username:
            return jsonify({"error": "Username ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤"}), 400
        
        # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
        user_data_dict = get_user_data(username)
        if user_data_dict is None:
            return jsonify({"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ"}), 404

        food_type_code_user, food_type_name_user = predict_food_type(user_data_dict)
        related_food_type_codes = get_related_food_types(food_type_code_user)
        related_food_type_names = [food_type_mapping[code] for code in related_food_type_codes]
        
        # ‡∏î‡∏∂‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ö‡∏≤‡∏á‡∏´‡∏°‡∏ß‡∏î‡∏Å‡πá‡πÑ‡∏î‡πâ)
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM food_menu")
        meals = cursor.fetchall()
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

        df_meals = pd.DataFrame(meals)
        predicted_types, valid_indices = predict_food_types_for_dataframe(df_meals)

        # ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
        matched_meals = []
        for idx, pred_type in zip(valid_indices, predicted_types):
            if pred_type in related_food_type_names:
                matched_meals.append(meals[idx])

        response_data = {
            "user_predicted_food_type_name": food_type_name_user,
            "user_predicted_food_type_code": int(food_type_code_user),
            "queried_based_on_type_names": related_food_type_names,
            "meals": matched_meals
        }
        return jsonify(response_data), 200, {'Content-Type': 'application/json; charset=utf-8'}

    except Exception as e:
        print(f"‚ùå Error in get_food_list: {e}")
        return jsonify({"error": str(e)}), 500

    
# API ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
@app.route('/get_unsuitable_food_list', methods=['POST'])
def get_unsuitable_food_list():
    try:
        data = request.get_json()
        username = data.get('username')
        if not username:
            return jsonify({"error": "Username ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á‡∏°‡∏≤"}), 400

        user_data_dict = get_user_data(username)
        if user_data_dict is None:
            return jsonify({"error": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ"}), 404

        predicted_code, predicted_name = predict_food_type(user_data_dict)
        suitable_codes = get_related_food_types(predicted_code)
        suitable_names = [food_type_mapping[c] for c in suitable_codes]

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM food_menu")
        meals = cursor.fetchall()
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

        df_meals = pd.DataFrame(meals)
        predicted_types, valid_indices = predict_food_types_for_dataframe(df_meals)

        # ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô suitable_names
        unmatched_meals = []
        for idx, pred_type in zip(valid_indices, predicted_types):
            if pred_type not in suitable_names:
                unmatched_meals.append(meals[idx])

        response_data = {
            "user_predicted_suitable_type_name": predicted_name,
            "user_predicted_suitable_type_codes": suitable_codes,
            "excluded_type_names": suitable_names,
            "meals": unmatched_meals
        }
        return jsonify(response_data), 200, {'Content-Type': 'application/json; charset=utf-8'}

    except Exception as e:
        print(f"‚ùå Error in get_unsuitable_food_list: {e}")
        return jsonify({"error": str(e)}), 500

     
# API ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏≤‡∏´‡∏≤‡∏£
@app.route('/save_meals', methods=['POST'])
def save_meals():
    try:
        # ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON ‡∏à‡∏≤‡∏Å request
        data = request.json
        username = data.get('username')
        meals_data = data.get('meals', {})
        date = data.get('date', datetime.now().strftime('%Y-%m-%d'))

        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
        if not username:
            return jsonify({'error': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 400
        if not meals_data:
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å'}), 400

        # ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_result = cursor.fetchone()
        if not user_result:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 404
        user_id = user_result['users_id']

        meals_saved_count = 0
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£
        for meal_type, foods_in_meal_type in meals_data.items(): # 
            if not isinstance(foods_in_meal_type, list): # Ensure it's a list of food items
                print(f"‚ö†Ô∏è Skipping meal_type '{meal_type}' as its value is not a list: {foods_in_meal_type}")
                continue
            # ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÉ‡∏ô list ‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (food_item)
            for food_item in foods_in_meal_type:
                if not isinstance(food_item, dict): 
                    print(f"‚ö†Ô∏è Skipping food_item as it's not a dictionary: {food_item} in meal_type '{meal_type}'")
                    continue
                
                # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
                food_id = food_item.get('food_id') 
                food_name = food_item.get('food_name')
                calories = food_item.get('calories', 0)
                protein = food_item.get('protein', 0)
                carbohydrate = food_item.get('carbohydrate', 0)
                # amount = food_item.get('amount', '1 ‡∏à‡∏≤‡∏ô') 
                image_url = food_item.get('image_url') 
                
                db_food_id_to_log = None

                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö food_id ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                if food_id and not str(food_id).startswith('temp-'):
                    cursor.execute("SELECT food_id FROM food_menu WHERE food_id = %s", (food_id,))
                    food_exists = cursor.fetchone()
                    if food_exists:
                        db_food_id_to_log = food_id
                    else: # food_id ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                        print(f"‚ö†Ô∏è food_id {food_id} ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô food_menu. ‡∏à‡∏∞‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡πâ‡∏≤‡∏°‡∏µ.")
                
                # ‡∏ñ‡πâ‡∏≤ food_id ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                if not db_food_id_to_log: # food_id ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                    if not food_name:
                        print(f"‚ö†Ô∏è Skipping food item due to missing food_name and unresolved food_id: {food_item}")
                        continue
                    
                    cursor.execute("SELECT food_id FROM food_menu WHERE food_name = %s", (food_name,))
                    existing_food_by_name = cursor.fetchone()
                    if existing_food_by_name:
                        db_food_id_to_log = existing_food_by_name['food_id']
                    else:
                        # ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á food_menu
                        # ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á food_menu
                        insert_query = """
                            INSERT INTO food_menu (food_name, calories, protein, carbohydrate, image_url)
                            VALUES (%s, %s, %s, %s, %s)
                        """
                        insert_values = (food_name, calories, protein, carbohydrate, image_url)
                        try:
                            cursor.execute(insert_query, insert_values)
                            db_food_id_to_log = cursor.lastrowid
                            print(f"‚úÖ Inserted new food: '{food_name}' with food_id: {db_food_id_to_log}")
                        except mysql.connector.Error as insert_err:
                            print(f"‚ùå Error inserting new food '{food_name}': {insert_err}")
                            continue # Skip this food item

                # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ food_id ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏•‡∏á‡πÉ‡∏ô food_history
                if db_food_id_to_log:
                    try:
                        cursor.execute("""
                            INSERT INTO food_history (users_id, food_id, his_date, meal_type)
                            VALUES (%s, %s, %s, %s)
                        """, (user_id, db_food_id_to_log, date, meal_type))
                        meals_saved_count += 1
                    except mysql.connector.Error as hist_err:
                        print(f"‚ùå Error inserting into food_history for food_id {db_food_id_to_log}: {hist_err}")
                else:
                    print(f"‚ö†Ô∏è Could not determine food_id for item: {food_item}, not saved to history.")


        conn.commit()
        return jsonify({
            'message': f'‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {meals_saved_count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£',
            'success': True,
            'meals_saved': meals_saved_count
        }), 200

    except Exception as e:
        if 'conn' in locals() and conn.is_connected(): conn.rollback() # Rollback on general error
        print(f"‚ùå Error in save_meals: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e), 'message': '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()



# API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡πÜ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
@app.route('/check_saved_meals', methods=['POST'])
def check_saved_meals():
    try:
        data = request.get_json()
        username = data.get('username')
        date = data.get('date')

        if not username or not date:
            return jsonify({'error': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà'}), 400

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_result = cursor.fetchone()

        if not user_result:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 404
        user_id = user_result['users_id']

        cursor.execute("SELECT COUNT(*) as count FROM food_history WHERE users_id = %s AND his_date = %s", (user_id, date))
        result = cursor.fetchone()
        has_meals = result['count'] > 0
        
        return jsonify({'has_meals': has_meals}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()

    

# API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
@app.route('/get_saved_meals', methods=['POST'])
def get_saved_meals():
    try:
        data = request.get_json()
        username = data.get('username')
        date = data.get('date')

        if not username or not date:
            return jsonify({'error': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà'}), 400

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_result = cursor.fetchone()
        if not user_result:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 404
        user_id = user_result['users_id']

        # Join with food_menu to get all details
        cursor.execute("""
            SELECT fh.meal_type, fm.food_id, fm.food_name, fm.calories, fm.protein, 
                   fm.carbohydrate, fm.sugar, fm.fat, fm.sodium, fm.image_url, fm.amount,
                   fm.category
            FROM food_history fh
            JOIN food_menu fm ON fh.food_id = fm.food_id
            WHERE fh.users_id = %s AND fh.his_date = %s
        """, (user_id, date))
        results = cursor.fetchall()

        meals_by_type = {} # Renamed variable
        for row in results:
            meal_type = row['meal_type']
            if meal_type not in meals_by_type:
                meals_by_type[meal_type] = []
            
            # Convert Decimal to float for relevant fields
            food_item_details = {}
            for key, value in row.items():
                if isinstance(value, decimal.Decimal):
                    food_item_details[key] = float(value)
                else:
                    food_item_details[key] = value
            
            # Ensure all expected keys are present, providing defaults if necessary
            # The query already selects all necessary fields from food_menu
            meals_by_type[meal_type].append({
                'food_id': food_item_details['food_id'],
                'food_name': food_item_details['food_name'],
                'calories': food_item_details.get('calories', 0.0),
                'protein': food_item_details.get('protein', 0.0),
                'carbohydrate': food_item_details.get('carbohydrate', 0.0),
                'sugar': food_item_details.get('sugar', 0.0),
                'fat': food_item_details.get('fat', 0.0),
                'sodium': food_item_details.get('sodium', 0.0),
                'amount': food_item_details.get('amount', '1 ‡∏à‡∏≤‡∏ô'),
                'image_url': food_item_details.get('image_url', 'default-image.jpg'),
                'category': food_item_details.get('category'),
            })
        
        return jsonify({'meals': meals_by_type}), 200, {'Content-Type': 'application/json; charset=utf-8'}

    except Exception as e:
        print(f"‚ùå Error in get_saved_meals: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()


# API ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
@app.route('/update_meals', methods=['POST'])
def update_meals():
    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡πÜ
    try:
        data = request.json
        username = data.get('username')
        meals_data = data.get('meals', {}) 
        date = data.get('date', datetime.now().strftime('%Y-%m-%d'))

        if not username:
            return jsonify({'error': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 400

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_result = cursor.fetchone()
        if not user_result:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 404
        user_id = user_result['users_id']

        # ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡πÉ‡∏ô food_history ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
        try:
            cursor.execute("DELETE FROM food_history WHERE users_id = %s AND his_date = %s", (user_id, date))
            print(f"‚ÑπÔ∏è Deleted old meal history for user {user_id} on date {date}. Rows affected: {cursor.rowcount}")
        except mysql.connector.Error as del_err:
            conn.rollback()
            print(f"‚ùå Error deleting old meal history: {del_err}")
            return jsonify({'error': '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤', 'details': str(del_err)}), 500
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà
        meals_saved_count = 0
        if meals_data: # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• meals_data ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            for meal_type, foods_in_meal_type in meals_data.items():
                if not isinstance(foods_in_meal_type, list): continue
                for food_item in foods_in_meal_type:
                    if not isinstance(food_item, dict): continue
                    
                    food_id = food_item.get('food_id')
                    food_name = food_item.get('food_name')
                    calories = food_item.get('calories', 0)
                    protein = food_item.get('protein', 0)
                    carbohydrate = food_item.get('carbohydrate', 0)
                    image_url = food_item.get('image_url')

                    db_food_id_to_log = None
                    if food_id and not str(food_id).startswith('temp-'):
                        cursor.execute("SELECT food_id FROM food_menu WHERE food_id = %s", (food_id,))
                        if cursor.fetchone():
                            db_food_id_to_log = food_id
                    
                    if not db_food_id_to_log:
                        if not food_name: continue
                        cursor.execute("SELECT food_id FROM food_menu WHERE food_name = %s", (food_name,))
                        existing_food_by_name = cursor.fetchone()
                        if existing_food_by_name:
                            db_food_id_to_log = existing_food_by_name['food_id']
                        else:
                            # ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á food_menu
                            try:
                                cursor.execute("""
                                    INSERT INTO food_menu (food_name, calories, protein, carbohydrate, image_url)
                                    VALUES (%s, %s, %s, %s, %s)
                                """, (food_name, calories, protein, carbohydrate, image_url))
                                db_food_id_to_log = cursor.lastrowid
                            except mysql.connector.Error as insert_err:
                                print(f"‚ùå Error inserting new food '{food_name}' during update: {insert_err}")
                                continue 

                    if db_food_id_to_log:
                        try:
                            cursor.execute("""
                                INSERT INTO food_history (users_id, food_id, his_date, meal_type)
                                VALUES (%s, %s, %s, %s)
                            """, (user_id, db_food_id_to_log, date, meal_type))
                            meals_saved_count += 1
                        except mysql.connector.Error as hist_err:
                             print(f"‚ùå Error inserting into food_history for food_id {db_food_id_to_log} during update: {hist_err}")

        conn.commit()
        return jsonify({
            'message': f'‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {meals_saved_count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£',
            'success': True,
            'meals_saved': meals_saved_count
        }), 200

    except Exception as e:
        if 'conn' in locals() and conn.is_connected(): conn.rollback()
        print(f"‚ùå Error in update_meals: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e), 'message': '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()
        

# API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
@app.route('/get_meal_status_for_month', methods=['POST'])
def get_meal_status_for_month():
    try:
        data = request.get_json()
        username = data.get('username')
        start_date_str = data.get('startDate')
        end_date_str = data.get('endDate')

        if not username or not start_date_str or not end_date_str:
            return jsonify({'error': '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ, ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô, ‡πÅ‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î'}), 400

        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()

        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        cursor.execute("SELECT users_id FROM users WHERE username = %s", (username,))
        user_result = cursor.fetchone()
        if not user_result:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ'}), 404
        user_id = user_result['users_id']
        
        cursor.execute("SELECT daily_calorie FROM profiles WHERE users_id = %s", (user_id,))
        profile_result = cursor.fetchone() # Renamed
        if not profile_result or profile_result['daily_calorie'] is None:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
            return jsonify({'error': '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏Ñ‡∏•‡∏≠‡∏£‡∏µ‡πà‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô NULL'}), 404
        daily_calorie = float(profile_result['daily_calorie']) # Ensure float

        cursor.execute("""
            SELECT his_date, SUM(fm.calories) as total_calories
            FROM food_history fh
            JOIN food_menu fm ON fh.food_id = fm.food_id
            WHERE fh.users_id = %s AND fh.his_date BETWEEN %s AND %s
            GROUP BY his_date
        """, (user_id, start_date, end_date))
        results = cursor.fetchall()

        meal_status_by_date = {} # Renamed
        for row in results:
            # ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏Ñ‡∏•‡∏≠‡∏£‡∏µ‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô
            total_calories = float(row['total_calories']) if row['total_calories'] is not None else 0.0
            
            lower_bound = daily_calorie * 0.9
            upper_bound = daily_calorie * 1.1
            status = 'perfect'
            if total_calories > upper_bound: status = 'over'
            elif total_calories < lower_bound: status = 'under'
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£
            meal_status_by_date[row['his_date'].strftime('%Y-%m-%d')] = {
                'total_calories': total_calories,
                'status': status
            }
        
        return jsonify({'mealStatus': meal_status_by_date}), 200

    except Exception as e:
        print(f"‚ùå Error in get_meal_status_for_month: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()
    
    
# API ‡∏î‡∏∂‡∏á‡πÇ‡∏†‡∏ä‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡πÄ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£
@app.route('/get_food_details', methods=['POST'])
def get_food_details():
    data = request.get_json()
    food_id = data.get('food_id')

    if not food_id:
        return jsonify({"success": False, "error": "Missing food_id"}), 400

    conn = get_db_connection()
    if not conn:
         return jsonify({"success": False, "error": "Database connection failed"}), 500

    cursor = conn.cursor(dictionary=True)

    try:
        query = """
            SELECT food_id, food_name, calories, protein, fat, carbohydrate, sugar, sodium, image_url, amount, category
            FROM food_menu 
            WHERE food_id = %s
        """
        cursor.execute(query, (food_id,))
        food_details_row = cursor.fetchone() # Renamed

        if food_details_row:
            processed_food_details = {}
            numeric_fields = ['calories', 'protein', 'fat', 'carbohydrate', 'sugar', 'sodium']
            for key, value in food_details_row.items():
                if isinstance(value, decimal.Decimal):
                    processed_food_details[key] = float(value)
                elif key in numeric_fields and value is None: # Handle None for numeric fields
                    processed_food_details[key] = 0.0 
                elif value is None: # Handle None for other (string) fields
                     processed_food_details[key] = "" # Or None, depending on frontend expectation
                else:
                    processed_food_details[key] = value
            
            # Ensure default for image_url if it was "" or None from DB
            if not processed_food_details.get('image_url'):
                processed_food_details['image_url'] = 'default-image.jpg'

            return jsonify({"success": True, "food_details": processed_food_details})
        else:
            return jsonify({"success": False, "error": "Food not found"}), 404

    except mysql.connector.Error as err:
        print(f"Database query error in get_food_details: {err}")
        return jsonify({"success": False, "error": f"Database query error: {err}"}), 500
    except Exception as e:
        print(f"Unexpected error in get_food_details: {e}")
        return jsonify({"success": False, "error": f"An unexpected server error occurred: {e}"}), 500
    finally:
        if 'cursor' in locals() and cursor: cursor.close()
        if 'conn' in locals() and conn and conn.is_connected(): conn.close()



if __name__ == "__main__":
    app.run(debug=True)